import os
from validators import Validator
from objects import Pawn
from uuid import uuid1
from random import choice
from json import load

# Optional imports
# TODO: Call pip procedure to install those libs if not found
config = load( open('config.json') )
if ( config['enable_plots'] ):
    from graphviz import Graph
    from PyPDF2 import PdfFileReader, PdfFileWriter


class Node():
    # Constructor
    def __init__(self, node_id, children, weight=0):
        self.node_id = node_id  # Movecode for that node
        self.children = children  # Nodes generated by this node


class Ai():
    # Constructor
    def __init__(self, game_judge, mode='exclusive'):
        self.pawns = [
            Pawn("black", "a3", silent=True),
            Pawn("black", "b3", silent=True),
            Pawn("black", "c3", silent=True),
            Pawn("white", "a1", silent=True),
            Pawn("white", "b1", silent=True),
            Pawn("white", "c1", silent=True)
        ]
        self.game_judge = game_judge
        self.nodes = []  # Node tree
        self.generation = 0  # Generation counter

        # Decision making
        self.wins = 0
        self.losses = 0
        self.last_move = ''

        # Modes
        # inclusive = Copies leaves that lead to victory
        # exclusive = Removes leaves that lead to defeat
        # both = inclusive + exclusive
        self.mode = mode  # Describes how the algorithm learns

        entry_moves = ['a2', 'b2', 'c2']
        # Test all entry moves and create all possible nodes
        for move in entry_moves:
            self.nodes.append(self.__make_nodes([move]))

        # Initial state snapshot graph
        if ( config['enable_plots'] ): self.__snapshot()

    # Generates nodes (neurons)
    def __make_nodes(self, movecode):
        # Reset the judge, so it can make
        # all moves from the beginning
        judge = Validator(self.pawns)
        judge.reset(True)

        # Execute the moves
        for code in movecode:
            judge.check(code, silent=True)

        # Results for this state
        children = []

        # Check if the moves resulted in victory
        judge.victory_validator(True)
        if (judge.white_wins == 1):
            judge.white_wins = 0
            return Node(movecode[::-1][0], children=[])
        elif (judge.black_wins == 1):
            judge.black_wins = 0
            return Node(movecode[::-1][0], children=[])

        # Sort pawns by color
        blacks = []
        whites = []
        for pawn in judge.group:
            if (pawn.color == 'black'):
                blacks.append(pawn)
            else:
                whites.append(pawn)

        # Check for all possible movements
        for pawn in (whites if (len(movecode) % 2 == 0) else blacks):
            [ children.append(move) for move in judge.get_movelist(pawn)]

        for node in children:
            idx = children.index(node)
            test = movecode.copy()
            test.append(node)
            children[idx] = self.__make_nodes(test)

        return Node(movecode[::-1][0], children)

    # Access the corresponding node
    def step(self):
        if (self.game_judge.stack != []):
            node = self.__traceroute(self.game_judge.stack)
            move = choice(node.children)
            self.game_judge.check(move.node_id)


    def update_nodes(self, color):
        # Get last black decision node (parent) and the child
        if (len(self.game_judge.stack) > 1):
            if (len(self.game_judge.stack) % 2 == 0):
                parent = self.__traceroute(self.game_judge.stack[0:len(self.game_judge.stack)-1])
                node = self.__traceroute(self.game_judge.stack)
            else:
                parent = self.__traceroute(self.game_judge.stack[0:len(self.game_judge.stack)-2])
                node = self.__traceroute(self.game_judge.stack[0:len(self.game_judge.stack)-1])

        # Compare the new win state
        if (color == 'black'):
            # The last move resulted in a win
            # copy that child if mode is inclusive or both
            print('[VICTORY] Blacks wins')
            if (self.mode in ['inclusive', 'both']):
                parent.children.append(node)

            # Update game score
            self.wins += 1

            # Update other game informations
            self.game_judge.stack = []
            self.generation += 1
            if ( config['enable_plots'] ): self.__snapshot()

        elif (color == 'white'):
            # The last move resulted in a lose
            # remove that child if mode is exclusive or both
            print('[VICTORY] White wins')
            if (self.mode in ['exclusive', 'both']):
                parent.children.remove(node)
        
            # Update game score
            self.losses += 1

            # Update other game informations
            self.game_judge.stack = []
            self.generation += 1
            if ( config['enable_plots'] ): self.__snapshot()


    # Advances in the tree
    def __traceroute(self, movecodes):
        actual_node = None
        for move in movecodes:
            scope = (actual_node.children if (
                actual_node != None) else self.nodes)
            for node in scope:
                if (node.node_id == move):
                    actual_node = node

        return actual_node

    # Only create plotting methods if enabled on config file
    if (config['enable_plots']):
        # Plot a graph containing all neurons at current state
        def __snapshot(self):
            # Initializing
            try: # Creates the plots dir if it doesn't exist
                os.mkdir('plots')
            except FileExistsError:
                pass

            dot = Graph(
                comment='HexaPawn',
                filename=os.path.join('plots', 'HexaPawn.gv')
            )
            dot.attr(
                center='true',
                rankdir='LR',
                ranksep='5.0 equally',
                label=f'Generation {self.generation}',
                fontsize='40'
            )

            # Create entry layer
            layers = {}
            links = []

            # Populate layers
            depth = 0
            parent_nodes = self.nodes
            while True:
                test = [True if (node.children != [])
                        else False for node in parent_nodes]
                if (test.count(True) > 0):
                    # Create layer nodes
                    layer = self.__create_layer(parent_nodes)

                    # Store layer
                    layers.update({str(depth): layer})

                    # Repeat the process using this layer's children
                    next_nodes = []
                    link = []
                    for node in parent_nodes:
                        for child in node.children:
                            next_nodes.append(child)
                            link.append([node.node_id, child.node_id])

                    links.append(link)

                    parent_nodes = next_nodes
                    depth += 1
                else:
                    break

            # Create the links
            for x in range(6):
                self.__linker(layers, links, x, dot)

            # Finally, render the graph
            dot.render()

            # Rename the output according to the current generation
            os.rename(os.path.join('plots', 'HexaPawn.gv.pdf'),
                    os.path.join('plots', f'{self.generation}.pdf'))

        # Merge all snapshots
        def plot(self):
            pdf_writer = PdfFileWriter()

            for x in range(self.generation + 1):
                pdf_reader = PdfFileReader(os.path.join('plots', f'{x}.pdf'))
                for page in range(pdf_reader.getNumPages()):
                    # Add each page to the writer object
                    pdf_writer.addPage(pdf_reader.getPage(page))

            # Write out the merged PDF
            with open(os.path.join('plots', 'generations.pdf'), 'wb') as out:
                pdf_writer.write(out)

            # Delete generation snapshot
            # (since it was added to the main file
            # we don't need it anymore)
            for x in range(self.generation + 1):
                os.remove(os.path.join('plots', f'{x}.pdf'))

        def __create_layer(self, parent_nodes):
            layer = {}
            for node in parent_nodes:
                node_id = str(uuid1())
                layer.update({node.node_id: node_id})

            return layer

        def __linker(self, layers, links, depth, dot):
            # Fetch layers
            try:
                layer = layers[f'{depth}']
                sublayer = layers[f'{depth + 1}']
            except:
                return None

            # Define node colors based on actual depth
            if (depth % 2 == 0):
                # Fill color, text color
                layer_style = ['white', 'black']
                sublayer_style = ['black', 'white']
            else:
                layer_style = ['black', 'white']
                sublayer_style = ['white', 'black']

            link = links[depth]
            for lk in link:
                dot.node(
                    name = layer[lk[0]], 
                    label = lk[0],
                    shape = 'circle',
                    width = '1',
                    height='1',
                    style = 'filled', 
                    fillcolor = layer_style[0],
                    fontcolor = layer_style[1]
                )
                tail = layer[lk[0]]

                dot.node(
                    name = sublayer[lk[1]], 
                    label = lk[1],
                    shape = 'circle',
                    width = '1',
                    height='1',
                    style = 'filled', 
                    fillcolor = sublayer_style[0],
                    fontcolor = sublayer_style[1]
                )
                head = sublayer[lk[1]]

                dot.edge(tail, head)
